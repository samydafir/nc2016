\documentclass[12pt,fleqn,a4paper]{article}

\usepackage{latexsym}
\usepackage{url}
\usepackage{xspace}
\usepackage{epsfig}
\usepackage{psfrag}
\usepackage{a4wide}
\usepackage{marvosym}
\usepackage{amsmath,amsfonts,amssymb,amsthm,latexsym}
\usepackage{graphics,graphicx,color,subfigure}
\usepackage{fancyhdr}
\usepackage[english]{babel}
\usepackage[latin1]{inputenc}
\usepackage{listings}
\usepackage{comment}

\textheight 680pt
\textwidth 460pt
\topmargin -40pt
\oddsidemargin 5pt
\evensidemargin 5pt
\parindent 0pt

\pagestyle{fancyplain} \setlength{\headheight}{16pt}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}
\lhead[\fancyplain{}{\thepage}]
    {\fancyplain{}{\rightmark}}
\rhead[\fancyplain{}{\leftmark}]
    {\fancyplain{}{\thepage}}
\cfoot{}
\renewcommand{\thesection}{\arabic{section}}
\renewcommand{\thesubsection}{\arabic{section}.\arabic{subsection}}


\begin{document}
\begin{titlepage}%Institution
\vspace{2cm}
\centerline{
\large{Department of Computer Sciences}}
\vspace{0.2cm}
\centerline{\large{University of Salzburg}}%Title with one or two Lines(More if wanted)
%\hline
\vspace{2cm}

\centerline{\large{PS Natural Computation}}
\centerline{SS 15/16}
\vspace{1cm}

\centerline{\Large{\bf{Evolution of a Poker Player Using Genetic Programming}} }%Type of the Document
\vspace{1cm}

\vspace{0.4cm}%Date
\centerline{\today}
\vspace{4.5cm}%Authors

%\hline
\vspace{0.2cm}
Project Members:\\
\centerline{Thomas Samy Dafir, 1331483, tdafir@cosy.sbg.ac.at}\\
\centerline{Laurentiu Vlad, 1423336, lvlad@cosy.sbg.ac.at}\\
\centerline{Dominik Baumgartner, 0920177, dbaumgart@cosy.sbg.ac.at}\\
\centerline{Sebastian Strumegger, 1420277, sstrumegg@cosy.sbg.ac.at}\\
\vspace {1cm}\\

Academic Supervisor: \\
\centerline{Helmut MAYER}
\centerline{helmut@cosy.sbg.ac.at}
\vspace{1.5cm}\\
Correspondence to: \\
\centerline{Universit\"{a}t Salzburg} \\
\centerline{Fachbereich Computerwissenschaften} \\
\centerline{Jakob--Haringer--Stra\ss e 2} \\
\centerline{A--5020 Salzburg} \\
\centerline{Austria}
\clearpage
\end{titlepage}

%Table of Content
\setcounter{page}{1}
\pagenumbering{Roman} %I,II,III... in the TOC
\tableofcontents

\clearpage
\pagestyle{headings}
\pagenumbering{arabic}  %Better if TOC is variable (more than one page)
\setcounter{page}{1}
\pagenumbering{arabic}  %Better if TOC is variable (more than one page)
\setcounter{page}{1}

\abstract{
This project is based on the evolution of a computer poker player by means of genetic programming. The initial population evolves through selection, mutation and crossover of their strategies represented as syntax trees. Evolution selects the best players of every generation based on their fitness value which corresponds to their won chips and hence the quality of their strategies. In the end the best player emerges.
The focus of this project lies on making more information available to each computer player in order to let them make better poker moves and ultimately lead to improved evolved players emerging from the evolutionary process. This is done through determining which information is relevant and making it available to be used in a players strategy. An important objective is not to improve strategies ourselves but rather provide information to computer players and let evolution run its course to to complete this task.
Furthermore fine tuning of evolutionary parameters like mutation rate, population size and number of generations was done to achieve the best possible result.

\begin{comment}
The goal of this project is to evolve a GP poker player by means of genetic programming techniques.
The GP Players evolve over generations through selection, mutation and cross mutation of their chromosome tree. \\
A good computer player has to emerge after a sufficient amount of generations have played in a "heads up" texas-hold-em no limit poker game.
Good players are determined by their fitness value which is determined through assessing a player's success after each poker round. \\
The focus of our work lies on the chromosome tree.
Although the current API provides some basics functions for that tree, it is likely that they are not sufficient for the evolution of a good player.
Further focus lies on the poker game itself.
We have to determine what kind of and how much information a player needs in order to evolve properly without interfering with its evolution.
This means, that we don't want to "tell" the player what the next best action is, but rather let evolution decide.
Additionally we will do some fine-tuning of evolutionary-parameters like population size or number of generations to achieve the best possible result.
\end{comment}
}

\newpage

%\input{gp.tex}

\newpage
\section{Genetic Programming}
\label{sec:genprog}
Genetic Programming is an evolutionary method that tries to solve a complex problem by evolution.
After defining the problem, an initial population is created which is going to be evolved.
Further a fitness function is needed, that determines how fit an individual is for the problem.
This can be for example the amount of won poker chips in a game.
Individuals with a high fitness value are considered fitter and are candidates for evolution, which are then evolved by mutation or crossover.
We will further use the example of a Genetic Programming poker player with a tree representation.

\subsection{Program Tree}
A GP Player is represented by a program tree. More precisely, the poker player's strategy is represented by this tree.\\
This means, that each player's tree has a root node and zero or more child nodes, where nodes with children are called functions and leaf nodes are called terminals.\\
From the very beginning there is a fixed set of functions and terminals available.
At first, a population of GP Players with random nodes are created which play a predetermined number of games.
In each generation there is a probability for every player to get its tree changed by mutation or crossover.


\subsubsection{Functions}
\label{sssec:functions}
Functions play the most important role in a GP Player's strategy, since functions are the decision-makers.\\
They can have one or more child nodes and a specific return type. Further all nodes (except the root)  need to have a parent node.
Child nodes can either be terminals or functions. It is vital that the child nodes return the very type the function expects.\\
As an example we could define a lower-than function that expects floating point values from both children and returns a boolean value to it's parent node.

\subsubsection{Terminals}
Terminals are the leaf nodes in a player's tree. They cannot have child nodes but return a certain type themselves.\\
This does not necessarily mean that a terminal's value has to be static. They can have dynamic values like "pot size" or "higher hand card".

\subsubsection{Root}
The root node is a special function, since it does not have any parent nodes.\\
For proper evaluation of the player's tree it needs to be rooted, so we can start making further decisions at one point.
For GPoker we need to have a root node that always returns a poker move which is returned to the game.\\

\newpage

\subsubsection{Example}
\begin{figure}[!ht]
\begin{center}
	\includegraphics[width=0.8\textwidth]{tree1.png}
\caption{Example Tree of a GP poker player}
\end{center}
\end{figure}
This very simple tree represents the following strategy:
~\\
If 0.6 (Two to Ace normalized in 0 to 1) is less than or equal to the player's lower hand card, make a call.\\
Else: check. Note that checking can also mean folding, in case there has been a raise.

\subsection{Evolution}
\label{evolution}
There are two ways for evolution to change a tree, namely crossover and mutation.

\subsubsection{Crossover}
Crossover takes two individual players and swaps random subtrees.
Of course both subtrees need to have the same return type.
This method is more common, since good players that were not sorted out by evolution usually have good subtrees.
So the the well-playing trees are not completely destroyed by the process of evolution, but there is much room for new combinations.

\begin{figure}
\begin{center}
	\includegraphics[width=1.0\textwidth]{tree_crossover.png}
\caption{Example for crossover}
\end{center}
\end{figure}

\subsubsection{Mutation}
In contrast to crossover, mutation does not require two individual trees to operate.
Either a single node is chosen at random and changed to some other random node with the same return type,
or a randomly chosen subtree is modified.

\begin{figure}
\begin{center}
	\includegraphics[width=1.0\textwidth]{tree_mutation.png}
\caption{Example for mutation}
\end{center}
\end{figure}
\newpage

\section{Frameworks}
\subsection{JEvolution}
JEvolution is a framework implementing several methods of evolutionary computing including Genetic Programming. JEvolution
conducts Genetic Programming as described in section \ref{sec:genprog}. It takes a node set and creates syntax trees. These
syntax trees are then evolved using selection, mutation and crossover. JEvolution selects trees with the highest fitness value. The fitness value has to correspond to the ability of a player to "survive" in the surrounding environment. In this application surviving means winning more chips and hence winning more games. Fitness calculation of a GPlayer is done by GPoker. 

\label{gpocker}
\subsection{GPoker}
GPoker is a poker-framework by Edgar Ebensberger \cite{GPoker}. GPoker implements a working no-limit no-rebuy Texas Hold'em poker setup. The implementation was done in Java. This object oriented approach made a design possible where aspects and components of a real poker game are represented directly by the class structure. These components include amongst others a dealer, players, strategies, cards and decks. GPoker allows the parameterization of many aspect of poker including the game-mode, big and small blinds as well as the involved players using a configuration file. There are preimplemented players including a check- and random-player as well as a player following a specific pattern and a human-player.
GPoker does not necessarily have to use genetic programming. Genetic programming and the evolution of a player is only invoked if a GPlayer is participating in a game.
If this is the case GPoker envokes JEvolution which then evolves the player using the supplied node-set. The nodeset determines which information is available to the player as well as which actions the player is able to perform. Nodes are divides into terinals and functions. The following nodes are already implemented \cite{GPoker}:

\begin{itemize}
	\item ConstMove: represents one of 4 four poker moves: Raise, Call, Check, Fold. Results in another random
	move if mutated
	\item ConstDouble: contains a constant double value ranging from 0.0 to 1.0
	\item VarDouble: contains a variable souble value ranging from 0.0 to 1.0. Originally only used to representate
	cards where 0.0 represents a deuce and 1.0 an ace. After extension of the framework VarDouble is now also used to
	hold hand values and the current game stage
	\item IfMove: checks a condition and executes the instructions in the left path if the condition is met otherwise the 
	right path gets excuted. Retrns a Move one of the four poker moves
	\item ConstBoolean: contains a constant boolean value ("true" or "false")
\end{itemize}

\subsection{Interaction}
Interactions between the two mentioned frameworks (namely JEvolution and GPoker) are essential to achieve the evolution of a poker player through Genetic Programming. Evolution works as follows:
\label{sec:nodes}
\begin{enumerate}
	\item A game of poker is startet through GPoker which checks if a GPlayer is amongst the players.
	\item If this is the case JEvolution is invoked to create an initial population of players represented by syntax trees
	made up from the nodes defined in GPoker.
	\item The fitness of each player (syntax tree) is determined by letting them play games of poker. The fitness value is defined as the total amount of chips a player has won.
	\item Selection is conducted on the population by selecting the players with the highest fitness values which are ultimately those who won the most chips and played best.
	\item The population size is then increased through mutation and crossover (more information in section \ref{sec:genprog}).
	\item Then the whole circle is repeated using this new generation.
	\item This is repeated until the defined amount of generations has been reached and ultimately the best player is selected.
\end{enumerate}

\newpage
\section{Experiment Setup}
For this experiment, some nodes got altered and one new node got introduced to test wether this results in a improved (higher) fitness of the evolved poker players. Two players, each with a different setup of nodes, evolved against the "PatternPlayer" and the "TestPlayer" in multiple runs.

\subsection{Alterations}
The following additions and alterations had been done to the fixed set of nodes explained in section \ref{sec:nodes}.\\\\
\underline{New:}\\
\textbf{IfDouble}: A function node (see \ref{sssec:functions}) that checks if a double value is present and executes the left path, otherwise the right path gets executed.\\\\
\underline{Changed:}\\
\textbf{RaiseMove}: A terminal node for raise which was previousely implemented in "ConstMove" (see \ref{gpocker}).\\
\textbf{NewConstMove}: The same terminal as "ConstMove" (see \ref{gpocker}) except that it now doesn't contain the raise anymore since raise is now a terminal on it's own.\\

The nodes in figure

\subsection{Node setup}
These are the node-setups for both players.\\
The player with Setup1 has the aforementioned new and altered nodes in his pool for evolution.\\
The player with Setup2 has the the original function- and terminal-set without any additional alterations.\\

\begin{figure}[!ht]
	\begin{center}
	\includegraphics[width=.3\textwidth]{new_node_table.png}
	\caption{All functions and terminals used in the experiment devided in setups per player}
	\end{center}
\end{figure}	

The nodes:
\begin{itemize}
	\item LessEqualBoolean
	\item ConstDouble
	\item VarDouble
	\item ConstBoolean
	\item MultDouble 
\end{itemize}
are of no particular interest in this experiment. They were choosen because we want to test if wider range of nodes is beneficial for the evolution. 

\begin{figure}[!ht]
\begin{center}
	\includegraphics[width=0.95\textwidth]{NewRaise.png}
	\caption{Example tree of an evolved player with setup 1}
\end{center}
\end{figure}

\subsection{Evolution against PatternPlayer}
\label{ssec:patternplayer}
The pattern player was choosen to evolve against, because it exhibits a play style that a new player to Texas Hold'em would have. Meaning that it plays defensively when his hand is not that great. It evaluates its hand (including community cards) and the hole cards. A normalized value is then calculated which in turn determines its next move.

\newpage

\subsection{Evolution against TestPlayer}
\label{ssec:testplayer}
One test player was choosen from previously evolved players which plays as follows.\\

\underline{Pseudocode:}\\

\textbf{if} highest card \textless \hspace*{0.5em}JACK \\
\hspace*{3em}\textbf{if} current bet for a call \textless \hspace*{0.5em}9 \\
\hspace*{3.9em} \textbf{return} CALL \\
\hspace*{2.5em} \textbf{else} \\
\hspace*{3.9em} \textbf{return} CHECK \\
\hspace*{1.5em} \textbf{else}  \\
\hspace*{3em} \textbf{return} RAISE(0.9849 * pot size) \\

\subsection{Fitness and fitness evaluation}
\label{fitness}
The fitness of a player is usually calculated via a fitness function which determines its performance or quality in the given environment. In the context of this project, the fitness is represented by the amount of chips a player had won.

\subsection{Selection and selection method}
\label{selection}
Some of the players of a given generation, are being selected in order to produce new player for the next generation. The selection method we chose is called "Tournament Selection" where the players with the highest fitness value of a parent population are picked in order to produce a new generation of players. The reason behind the concept of choosing the ones with the highest fitness is that they are more likely to produce new players that are "good" players (the ones achieving high fitness scores). 

\subsection{Doyle's Game}
\label{doyle}
Doyle's Game is a variant of no-limit Texas Hold'em and is being used in this experiment. In this variant of the game, each player can make an "all-in" bet, but the players stack size (the amount of chips a player has before making any bet, blinds included) are reset to some default size/amount after each hand. The won or lost chips of every player is stored separately for each one and does not affect the starting chips of the following games.\\\\
This approach prevents two problems:
\begin{itemize}
	\item a player going bankrupt during a game. Avoiding this is desirable since we want to evaluate each player against each opponent.
	\item a player having far more chips than his opponents since this can lead to all-in bets of unequal sizes between players.
\end{itemize}

\newpage
\subsection{Input parameter}
\label{inputparameter}
For both experiments the parameters were chosen as follows: 
\begin{itemize}
	\item Game Mode: Doyle (see \ref{doyle})
	\item Test-Runs: 8 for each player
	\item Generations: 10.000
	\item Population-Size: 100
	\item Rounds played per generation: 1000
	\item Mutation-Rate: 0.0369 (see \ref{evolution})
	\item Crossover-Rate: 1.0 (see \ref{evolution})
	\item Selection Method: Tournament selection (see \ref{selection})
	\item Chips/Player: 1000 
	\item Big blind: 10
\end{itemize} 
A generation of 10.000 seemed to be sufficient for an overall assessment of the fitness. In test runs using 20.000 generation it was noticed that
the player with the highest fitness would always emerge within the 10.000th generation.

\section{Experiment Results}
These are the results after doing 8 test-runs per setup ........

\subsubsection{Evolution against PatternPlayer}
During evolution against the PatternPlayer it was noted that the changes led to a deterioration of the GPlayer's fitness.\\
\\
Average calculated fitness of the \textbf{setup 1}: 102001\\
Average calculated fitness of the \textbf{setup 2}: 113168
\begin{center}
	\includegraphics[width=.9\textwidth]{gp_vs_pp_new.png}
\end{center}

\subsubsection{Evolved trees against the PatternPlayer}
\texttt{ifm <=d cd[0,8291] cd[0,2086] rcm[Check] rm /d vard[1] *d *d cd[0,5560] cd[0,0537] *d cd[0,0519] cd[0,9908]} \\ \\
\texttt{ifm <=d cd[0,1068] *d cd[0,7747] vard[1] rm cd[0,4432] rm *d vard[0] cd[0,9040]}\\ \\
\texttt{ifm <=d vard[1] *d cd[0.5569] vard[0] ifm <=d cd[0.3677] vard[0] rm *d cd[0.0629] cd[0.1581] ncm[Check] ncm[Call]}\\ \\
\texttt{ifm <=d vard[0] cd[0,6326] ifm <=d vard[1] *d cd[0,3969] vard[0] ncm[Check] ncm[Call] rm cd[0,5256]}\\ \\
\texttt{ifm <=d cd[0,5573] vard[0] rm *d cd[0,7988] *d cd[0,3149] cd[0,3444] ifm <=d *d vard[0] cd[0,5125] vard[1] ncm[Call] ncm[Check]}

\subsubsection{Evolution against TestPlayer}
Overall it is safe to say that the changes improved the performance against the TestPlayer. Although there can be some cases where the old player has a higher fitness than the new one. It was also notable that the overall fitness is cut down to approximately a third compared to the test runs against the PatternPlayer. This is most likely due to the TestPlayer unlike the PatternPlayer making objectively decent moves which results in the GPlayer having a more difficult opponent and hence winning less chips.\\
\\
Average calculated fitness of the player with \textbf{setup 1}: 31153\\
Average calculated fitness of the player with \textbf{setup 2}: 26710

\begin{center}
	\includegraphics[width=.9\textwidth]{gp_vs_tp_new.png}
\end{center}

\subsubsection{Evolved trees against the TestPlayer}
\texttt{ifm <=d cd[0.5750] vard[0] rm cd[0.3671] ifm <=d vard[0] vard[1] ncm[Call] ncm[Check]} \\ \\
\texttt{ifm <=d cd[0.6027] vard[0] rm cd[0.8510] ifm <=d *d *d vard[0] cd[0.5788] cd[0.9339] vard[1] ncm[Call] ncm[Check]}\\ \\
\texttt{ifm <=d cd[0,1670] *d cd[0,3417] *d cd[0,7303] cd[0,9367] rm cd[0,9624] ncm[Check]}\\ \\
\texttt{ifm <=d cd[0,8291] cd[0,2086] rcm[Check] rm /d vard[1] *d *d cd[0,5560] cd[0,0537] *d cd[0,0519] cd[0,9908]}\\ \\
\texttt{ifm <=d cd[0,4988] /d *d cd[0,2995] cd[0,5651] cd[0,0693] rm /d cd[0,5110] *d *d vard[1] vard[0] ifd cb[false] cd[0,3461] cd[0,5974] rcm[Check]}

\newpage
\section{Conclusion}
Theoretically speaking our alterations provide the player with more information about the current state of the game. This enables the evolution of factors on which the player decides on how high the raise value
shall be. So from a theoretical point of view it is pretty clear that these alterations will lead to the evolution yielding better players. Analyzing our results this assumption can only be confirmed partly. As has been shown the improvement/deterioration is highly dependent on the player against which the GPlayer plays during evolution. This is most likely due to the computer players using different strategies of which one can be easily exploited by the GPlayer using the new function-set whereas the other seems to be more robust. Finally we conclude that although there have been some negative results while playing against the PatternPlayer the result is quite positive. The players emerging after the alterations were made seem to make good decisions and queries (from a poker point of view). Additionally our changes have led to a fairly significant improvement when playing against a player who makes decisions and moves a decent human poker player might make (TestPlayer). 

% links go here, NOT in references

\section{Links}

\begin{itemize}
\item Project Page: \url{https://student.cosy.sbg.ac.at/~tdafir/nc/}
\item PS Page:
\url{http://www.cosy.sbg.ac.at/~helmut/Teaching/NaturalComputation/proseminar.html}

\end{itemize}

\nocite{*}
\bibliographystyle{ieeetr}
\bibliography{report_refs}		% .bib files here

\end{document}
