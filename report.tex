\documentclass[12pt,fleqn,a4paper]{article}

\usepackage{latexsym}
\usepackage{url}
\usepackage{xspace}
\usepackage{epsfig}
\usepackage{psfrag}
\usepackage{a4wide}
\usepackage{marvosym}
\usepackage{amsmath,amsfonts,amssymb,amsthm,latexsym}
\usepackage{graphics,graphicx,color,subfigure}
\usepackage{fancyhdr}
\usepackage[english]{babel}
\usepackage[latin1]{inputenc}
\usepackage{listings}

\textheight 680pt
\textwidth 460pt
\topmargin -40pt
\oddsidemargin 5pt
\evensidemargin 5pt
\parindent 0pt

\pagestyle{fancyplain} \setlength{\headheight}{16pt}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}
\lhead[\fancyplain{}{\thepage}]
    {\fancyplain{}{\rightmark}}
\rhead[\fancyplain{}{\leftmark}]
    {\fancyplain{}{\thepage}}
\cfoot{}
\renewcommand{\thesection}{\arabic{section}}
\renewcommand{\thesubsection}{\arabic{section}.\arabic{subsection}}


\begin{document}
\begin{titlepage}%Institution
\vspace{2cm}
\centerline{
\large{Department of Computer Sciences}}
\vspace{0.2cm}
\centerline{\large{University of Salzburg}}%Title with one or two Lines(More if wanted)
%\hline
\vspace{2cm}

\centerline{\large{PS Natural Computation}}
\centerline{SS 15/16}
\vspace{1cm}

\centerline{\Large{\bf{Evolution of a Poker Player Using Genetic Programming}} }%Type of the Document
\vspace{1cm}

\vspace{0.4cm}%Date
\centerline{\today}
\vspace{4.5cm}%Authors

%\hline
\vspace{0.2cm}
Project Members:\\
\centerline{Thomas Samy Dafir, 1331483, tdafir@cosy.sbg.ac.at}\\
\centerline{Laurentiu Vlad, 1423336, lvlad@cosy.sbg.ac.at}\\
\centerline{Dominik Baumgartner, 0920177, dbaumgart@cosy.sbg.ac.at}\\
\centerline{Sebastian Strumegger, 1420277, sstrumegg@cosy.sbg.ac.at}\\
\vspace {1cm}\\

Academic Supervisor: \\
\centerline{Helmut MAYER}
\centerline{helmut@cosy.sbg.ac.at}
\vspace{1.5cm}\\
Correspondence to: \\
\centerline{Universit\"{a}t Salzburg} \\
\centerline{Fachbereich Computerwissenschaften} \\
\centerline{Jakob--Haringer--Stra\ss e 2} \\
\centerline{A--5020 Salzburg} \\
\centerline{Austria}
\clearpage
\end{titlepage}

%Table of Content
\setcounter{page}{1}
\pagenumbering{Roman} %I,II,III... in the TOC
\tableofcontents

\clearpage
\pagestyle{headings}
\pagenumbering{arabic}  %Better if TOC is variable (more than one page)
\setcounter{page}{1}
\pagenumbering{arabic}  %Better if TOC is variable (more than one page)
\setcounter{page}{1}

\abstract{
The goal of this project is to evolve a GP poker player by means of genetic programming techniques.
The GP Players evolve over generations through selection, mutation and cross mutation of their chromosome tree. \\
A good computer player has to emerge after a sufficient amount of generation have played in a "heads up" texas-hold-em no limit poker game.
Good players are determined by their fitness value which is determined through assessing a player's success after each poker round. \\
The focus of our work lies in the chromosome tree.
Although the current API provides some basics functions for that tree, it is likely that they are not sufficient for the evolution of a good player.
The second focus lies on the poker game itself.
We have to determine what kind and how much information a player needs in order to evolve properly without interfering with its evolution.
This means, that we don't want to "tell" the player what the next best action is, but rather let evolution decide.
Additionally we will do some fine-tuning of evolutionary-parameters like population size or number of generations to achieve the best possible result.
}

\newpage

%\input{gp.tex}

\newpage

\input{frameworks.tex}

\newpage
\section{Genetic Programming}
\label{sec:genprog}
As mentioned, a GP Player is represented by a so-called chromosome tree. Or more precisely, the poker player's strategy is represented by this tree.\\
This means, that each player's tree has a root node and zero or more child nodes, where nodes with children are called functions and leave nodes are called terminals.\\
From the very beginning there is a fixed set of functions and terminals available.
At first, a population of GP Players with random nodes are created which play a predetermined number of games.
In each generation there is a chance for every player that it's tree is changed by mutation or crossover.

\subsection{Chromosome Tree}
\subsubsection{Functions}
Functions play the most important role in a GP Player's strategy, since functions are the decision-makers.\\
They can have one or more child nodes and a specific return type. Further all nodes (except the root)  need to have a parent node.
Child nodes can either be terminals or functions, where it is also very important that the child nodes return the very type the function expects.\\
As an example we could define a lower-than function that expects floating point values from both children and returns a boolean value to it's parent node.

\subsubsection{Terminals}
Terminals are the leave nodes in a player's tree. They cannot have child nodes but return a certain type themselves.\\
This does not necessarily mean that a terminal's value has to be static. They can have dynamic values like "pot size" or "higher hand card".

\subsubsection{Root}
The root node it a special function, since it does not have any parent nodes.\\
For a proper evaluation of the player's tree it needs to be rooted, so we can start making further decisions at one point.
For GPoker we need to have a root node that always returns a poker move which is returned to the game.\\
~\\
A GPlayer, for example, uses the root node "IfMove" which has three children:\\
The very left child is the if-condition, that needs to return a boolean type.\\
The middle child is the then-branch and returns a move.\\
And at last, the right child represents the else-branch, which also returns a move.\\

\newpage

\subsubsection{Example}
\begin{center}
	\includegraphics[width=0.8\textwidth]{tree1.png}
\end{center}
This very simple tree represents the following strategy:
~\\
If 0.6 (Two to Ace normalized in 0 to 1) is less than or equal to the player's lower hand card, make a call.\\
Else: check. Note that checking can also mean folding, in case there has been a raise.

\subsection{Evolution}
There are two fundamentally different ways for evolution to change a tree, namely crossover and mutation.

\subsubsection{Crossover}
Crossover takes two individual players and swaps subtrees in a random point.
Of course both subtrees need to have the same return type.
This method is more common, since good players that were not sorted out by evolution usually have good subtrees.
So the the well-playing trees are not completely destroyed by the process of evolution, but there is much room for new combinations.

\begin{center}
	\includegraphics[width=1.0\textwidth]{tree_crossover.png}
\end{center}

\subsubsection{Mutation}
In contrast to crossover, mutation does not require two individual trees to operate.
Either a single node is chosen at random and changed to some other random node that returns the same type,
or a randomly chosen subtree is modified.
Mutation has to be used carefully, since random changes can render a very good player useless.

\begin{center}
	\includegraphics[width=1.0\textwidth]{tree_mutation.png}
\end{center}

\newpage
\section{Implementation}
\subsection{Initial changes}
As mentioned above, our focus in this work was to change existing nodes and/or add
new nodes to the chromosome tree. When we first evaluated the existing code, especially the implemented functions and terminals, we observed that the raise value was randomly calculated [0.0 to 2.0 * pot]. The value was neither decided nor influenced by evolution. \\
Raising plays a vital role in a Texas Hold'em No Limit poker game and this was also noticed by the evolution which often returned players who's trees were made up of a single raise node.
Therefore we decided to concentrate on making the raise node accessible to the evolution so its value can be evolved.
\\ \\ 
The first attempt was to allow the raise leaf-node to have a subtree which would potentially get evolved. For this purpose we introduced a new function node called "IfDouble". It evaluates a boolean expression and returns a double value which is the factor of the raise [i.e 1,9397 * pot size]. In this case, a ConstMove terminal could either be a terminal or a function node.

\begin{center}
	\includegraphics[width=0.86\textwidth]{raise_subtree_1.png}
	\textit{\textbf{Figure 1: }Example tree of an evolved player with a IfDouble-subtree appended to raise}
\end{center}

This however led to undesirable mutations like the following:
\begin{itemize}
	\item GPoker produced IfDouble-Nodes that only have one child
	(ConstBoolean).
	\item GPoker produced ConstMove(RAISE) Nodes that have a
	ConstDouble child which does not get evaluated.
\end{itemize}

\newpage
\subsection{Final implementation}
\subsubsection{Raise}
As a final solution, the raise move was moved out from ConstMove and redesigned as an independent function node. It still has only one child but now the lines between a function and a terminal are not blurred anymore. With this change, the evolution can now remove raise entirely if it finds that it is not a good functions. In addition to that, it is now easier to mutate the factor of a raise which is more dynamic and granular. \\
This is due to a raise subtree now being able to grow or shrink and build up different calculations for the raise factor like multiplying the high card with another factor. Also any node returning double can be attached to the new raise node.

\subsubsection{Fold}
After some testing we noticed that sometimes a player would emerge that would always fold. A fold-only player does not make any sense since it would gradually lead to the loss of all the player's chips. Although this is a crucial mechanism and a valid move, we deleted fold from the ConstMove class to avoid these kinds of players. ConstMove is now limited to returning a "Call" or "Check". \\
This is possible because the \textit{checkMove(Player player, Move move)} method of the "Dealer" class handles invalid player moves and automatically folds [i.e. when a player checks in response to a raise].

\begin{center}
	\includegraphics[width=0.95\textwidth]{NewRaise.png}
	\textit{\textbf{Figure 2: }Example tree of an evolved player after the final implementation}
\end{center}

\newpage
\section{Experiments}
For the experiments we evolved two GPlayers both against a "PatternPlayer" and a "TestPlayer" in multiple runs. The first player was the one with the original function- and terminal-set and had no additional alterations. The second player had the aforementioned changes applied. After all test runs were completed the fitness of the old and new player were compared.

\subsection{Setup}
Nodes used:
\begin{flushleft}
	\includegraphics[width=.3\textwidth,left]{node_table.png}
\end{flushleft}	

\subsubsection{Evolution against PatternPlayer}
The way the PatternPlayer plays is by evaluting his hand value and the overall values of the cards [deviding their rank by an ace and adding those values together].
The move made depends on their normalized value.

\subsubsection{Evolution against TestPlayer}
One TestPlayer was choosen from previously evolved players that made sane moves and played as follows.
\\
\begin{lstlisting}
	if (getCards().get(1).getRank() < Card.JACK) {
	  if (dealer.getCallBet(this) < 9)
		move.setType(Move.CALL);
	  else
		move.setType(Move.CHECK);
	}else
	  move.setBet((int)(0.9849 * dealer.getPot()));
		
	return move;
\end{lstlisting}
\\
In short, this player was playing more defensively and only performed a "Call" or "Check" when his highest card was lower than a JACK. If his highest card was better he played aggressively and raised with a value of 0.9849 * pot-size.

\newpage
\subsubsection{Experiment parameter}
For both experiments the parameter were chosen as follows: 
\begin{itemize}
	\item Game Mode:       Doyle
	\item Test-Runs:       8 for each player
	\item Generations:     10.000
	\item Population-Size: 100
	\item Rounds:          1000
	\item Mutation-Rate:   0.0369
\end{itemize}
\\ 
\\
A generation of 10.000 seems to be sufficient for an overall assessment of the fitness. It was noticed from previous test runs, with a generation size of 20.000, that the best players would emerge all within the threshold of 10.000 .

\subsection{Results}
The following diagrams show the fitness of the old and new player of each run. \\
On the y-axis the fitness is plotted and the x-axis displays one run. The values had been sorted in an ascending order to have a better interpretation basis because the order of the runs do not play any particular role. In short, the diagram does not show a function. This needs to be kept in mind when assessing the diagrams.
\subsubsection{Evolution against PatternPlayer}
The evolution against the PatternPlayer resulted in a disimprovement of the GPlayer.  \\ \\
The average calculated fitness of the new GPlayer: 102001\\
The average calculated fitness of the old GPlayer: 113168
\begin{center}
	\includegraphics[width=.9\textwidth]{gp_vs_pp_1.png}
\end{center}
\\
\textbf{Evolved trees against the PatternPlayer}\\ \\
\texttt{ifm <=d cd[0,8291] cd[0,2086] rcm[Check] rm /d vard[1] *d *d cd[0,5560] cd[0,0537] *d cd[0,0519] cd[0,9908]} \\ \\
\texttt{ifm <=d cd[0,1068] *d cd[0,7747] vard[1] rm cd[0,4432] rm *d vard[0] cd[0,9040]}\\ \\
\texttt{ifm <=d vard[1] *d cd[0.5569] vard[0] ifm <=d cd[0.3677] vard[0] rm *d cd[0.0629] cd[0.1581] ncm[Check] ncm[Call]}\\ \\
\texttt{ifm <=d vard[0] cd[0,6326] ifm <=d vard[1] *d cd[0,3969] vard[0] ncm[Check] ncm[Call] rm cd[0,5256]}\\ \\
\texttt{ifm <=d cd[0,5573] vard[0] rm *d cd[0,7988] *d cd[0,3149] cd[0,3444] ifm <=d *d vard[0] cd[0,5125] vard[1] ncm[Call] ncm[Check]}

\subsubsection{Evolution against TestPlayer}
Overall it is safe to say that the changes improved the performance against the TestPlayer. Although there can be some cases where the old player has a higher fitness than the new one. Also notable is that the overall fitness is cut down to approximately a third compared to the test runs against the PatternPlayer. \\ \\
The average calculated fitness of the new GPlayer: 31153\\
The average calculated fitness of the old GPlayer: 26710

\begin{center}
	\includegraphics[width=.9\textwidth]{gp_vs_tp_1.png}
\end{center}
\\
\textbf{Evolved trees against the TestPlayer}\\ \\
\texttt{ifm <=d cd[0.5750] vard[0] rm cd[0.3671] ifm <=d vard[0] vard[1] ncm[Call] ncm[Check]} \\ \\
\texttt{ifm <=d cd[0.6027] vard[0] rm cd[0.8510] ifm <=d *d *d vard[0] cd[0.5788] cd[0.9339] vard[1] ncm[Call] ncm[Check]}\\ \\
\texttt{ifm <=d cd[0,1670] *d cd[0,3417] *d cd[0,7303] cd[0,9367] rm cd[0,9624] ncm[Check]}\\ \\
\texttt{ifm <=d cd[0,8291] cd[0,2086] rcm[Check] rm /d vard[1] *d *d cd[0,5560] cd[0,0537] *d cd[0,0519] cd[0,9908]}\\ \\
\texttt{ifm <=d cd[0,4988] /d *d cd[0,2995] cd[0,5651] cd[0,0693] rm /d cd[0,5110] *d *d vard[1] vard[0] ifd cb[false] cd[0,3461] cd[0,5974] rcm[Check]}

\newpage

% links go here, NOT in references

\section{Links}

\begin{itemize}
\item Project Page: \url{https://student.cosy.sbg.ac.at/~tdafir/nc/}
\item PS Page:
\url{http://www.cosy.sbg.ac.at/~helmut/Teaching/NaturalComputation/proseminar.html}

\end{itemize}

\nocite{*}
\bibliographystyle{ieeetr}
\bibliography{report_refs.bib}		% .bib files here

\end{document}
